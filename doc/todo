
TO-DO
=====

Debug the record sorter

  There might be a bug causing module and sig bindings to get added to their own
  ref sets

Finish the record sorting phase

  Make a function that maps a decl to all the BindNames it contains

    Use it to produce error messages for cycles

    We could use this to get rid of the two-phase approach with the LHS and the RHS

      Instead, just allocate uniques for all the BindNames up front by finding them
      all with this function; then, with the necessary mappings added to the scope,
      traverse the AST, replacing both the BindNames that perform binding and those
      that just appear in Refs in the same pass

Consider requiring a special symbol to be prefixed onto any global Ref

Add location information to the syntax tree via an L type like in GHC

  Also wrap errors in the L type

  Use monad magic to make this all nicer to deal with:

    Say we have an existing function T -> M a.

    Now, we want to operate on an L T instead.

    So, we have a combinator LF :: (b -> M a) -> (L b -> M a)

    Here's how it works:

      There's a current location in the environment.

      LF takes the input, strips off the location, and feeds the real input to the
      given function, but returns that function wrapped in a local environment where
      the current location has been set to the extracted location.

      Then, when reporting an error, the existing report function can simply pull the
      current location out of the environment.

Write a pretty-printer back to real syntax

  Use intelligent line-breaking when faced with a long expression
  * Prefer to break lines higher up in the AST, rather than at the latest possible
    moment
    * But do this in a generic way: send a stream of information to the "output"
      which includes:
        * Tokens to print, with rules for adding adjacent spaces
        * Mandatory newlines
        * Ident and dedent
        * Syntactic descent and ascent
          * Use these to find better places to break lines

  Note: dealing with operators correctly requires knowing the precedence of each
  operator reference, which requires the resolution phase to be implemented.

Fix this weird thing: in a case-function, in an else clause, you might want to bind
the arguments to variables. But you can't. So you have to use an "if" with all plain
variables, which just makes it less obvious what it really is. So, allow the else
clause to have pattern bindings. (This can be useful even in normal cases, actually.)

Allow multiple "if" clauses to be stacked with a single result body, so long as all
clauses bind the same set of variables with the same types (or compatible types).

Add syntax for decision tables

Add a new form of type constraints that limit effects

Think about how to solve the problem of the fact that many sigs could be
expressed in many equivalent ways, and whichever of the ways we don't choose
would have provided all kinds of utility functions that will end up defined
outside the sig. But it seems unnatural to force a particular choice of
definining functions across all implementations of that sig.

  This could be a great use of something like datalog. Let the author of the sig
  give rules describing whether or not any particular subset of the functions makes
  a valid implementation.

Think about how to make sigs and modules as easy to use as typeclasses in the common
case.

Add syntax for declaring view types
  This is a data type combined with a function from some other type to that data type.
  The view type cannot be directly pattern-matched - any pattern match using the view
  type implicitly expects a value of the input type, which is then transformed with the
  view function.

Allow patterns in let bindings

Find keywords that can be allowed as identifiers

There is ambiguity in the "open" expression

Figure out how to do lenses nicely

Figure out how to allow sigs inside parameterized modules

Add syntax to allow long strings to be written as multiple adjacent strings which
are concatenated during parsing


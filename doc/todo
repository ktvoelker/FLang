
TO-DO
=====

The semicolons are unfortunate! Try to eliminate them to make case blocks look nicer.
  Periods?
  Curly braces?

  Using the word "is" might have been a mistake, since it feels incomplete without
    a trailing "end", which is often incorrect.

    The Scala convention might work well here: an equals leads into an "expressiony"
    thing that doesn't have an end delimiter (except when it's part of a group of
    like things, in which case it is ended by a semicolon). Special words introduce
    blocks that are ended with "end". (We could require a semicolon after each mod
    decl to make things more consistent.)

      Maybe we can keep more of the existing syntax but just use curly braces in places
      where we use "end" right now. They'd be matching, so it would be easier to figure
      out when you need an ending one.

Think about nicer function definition syntax, too.

Bring back a nicer syntax for defining modules and sigs

Make it possible to define an "otherwise" case in a function-case without having to
write one underscore for each argument.

Add simpler syntax for the common cases of algebraic data types

Add syntax for decision tables

Add a new form of type constraints that limit effects

Think about how to solve the problem of the fact that many sigs could be
expressed in many equivalent ways, and whichever of the ways we don't choose
would have provided all kinds of utility functions that will end up defined
outside the sig. But it seems unnatural to force a particular choice of
definining functions across all implementations of that sig.

  This could be a great use of something like datalog. Let the author of the sig
  give rules describing whether or not any particular subset of the functions makes
  a valid implementation.

Think about how to make sigs and modules as easy to use as typeclasses in the common
case.

Add syntax for declaring view types
  This is a data type combined with a function from some other type to that data type.
  The view type cannot be directly pattern-matched - any pattern match using the view
  type implicitly expects a value of the input type, which is then transformed with the
  view function.

